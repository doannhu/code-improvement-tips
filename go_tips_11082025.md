2. Use Interfaces for Decoupling
Senior engineers know that tightly coupling code makes testing and scaling painful.

# An example of bad code:

package orders

import "myapp/postgres" 

type OrderService struct{}

func (s OrderService) Get(id string) (Order, error) {
    return postgres.DB.GetOrder(id) // uses package global
}

func (s OrderService) Update(o Order) error {
    return postgres.DB.UpdateOrder(o)
}


Instead of calling db.GetOrder() directly, abstract it behind an interface:

type OrderStore interface {
    GetOrder(id string) (Order, error)
    UpdateOrder(order Order) error
}

type OrderSerive struct {
    o OrderStore
}

func (service OrderService) Mangeorder(id string, loader func() (string, error)) (Order, error) {
    if order, ok := service.o.GetOrder(id); ok {
        return order, nil
    }

    order, err := loader()
    if err != nil {
        return "", err
    }

    _ = service.o.UpdateOrder(order)

    return order, nil

} 

# Another bad code example:

package notify

import "myapp/sqs"

type OrderNotifier struct{}

func (n OrderNotifier) OrderCreated(o Order) error {
    b, _ := json.Marshal(o)
    return sqs.Client.Publish("orders.created", b)
}

Instead, use interface:

type Publisher interface {
    Publish(topic string, payload []byte) error
}

type OrderNotifier struct{ pub Publisher }

func (n OrderNotifier) OrderCreated(o Order) error {
    b, _ := json.Marshal(o)
    return n.pub.Publish("orders.created", b)
}


Your service code can then depend on OrderStore, not a specific database implementation. This makes swapping databases—or mocking for tests—effortless.