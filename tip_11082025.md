1. Think in Layers, Not Files
Instead of dumping code into a utils.py file or keeping everything in main.py, senior engineers split responsibilities by layers:

Presentation Layer → Handles I/O (e.g., CLI, REST APIs, Web UI)
Service Layer → Contains business logic
Data Layer → Deals with storage, databases, APIs, etc.
Example structure:

project/
├── app/
│   ├── __init__.py
│   ├── api/               # Presentation Layer
│   ├── services/          # Business Logic Layer
│   └── repositories/      # Data Access Layer
├── tests/
├── scripts/
├── config/
└── main.py
This separation makes your code easier to test, debug, and refactor over time.

2. Use a Package, Not a Pile of Scripts
A senior dev treats their project like a distributable package, even if it’s just internal.

Why?
Cleaner imports
Easier testing
Future-ready for deployment or packaging
Set up your package like this:

project/
├── my_project/
│   ├── __init__.py
│   ├── core/
│   ├── utils/
│   └── ...
├── setup.py
└── pyproject.toml
With this structure, you can do:

from my_project.core.service import BusinessLogic
Much cleaner than relative imports from random scripts.

3. Structure Tests to Mirror the App
Tests aren’t an afterthought — they’re a first-class citizen.

Mirror your app’s structure:

tests/
├── api/
├── services/
└── repositories/
Each test module should correspond to a source module. It makes it easier to locate and maintain.

Use pytest and make testing a habit, not a headache.

4. Configuration Should Be Environment-Agnostic
Avoid hardcoding configuration in your code.

Use a central config module that pulls from:

.env files using python-dotenv
environment variables
config files (like YAML, TOML, or JSON)
Example:

# config/settings.py
import os

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///local.db")
DEBUG = os.getenv("DEBUG", "false").lower() == "true"
Pro tip: Also add config/__init__.py and expose the config cleanly.

5. Dependency Injection > Global Imports
Senior engineers avoid tight coupling by injecting dependencies.

Instead of:

from database import db
user = db.get_user()
Prefer:

def get_user_service(db_client):
    return db_client.get_user()
This improves testability and keeps your logic decoupled from specific tools or frameworks.

6. CLI or Entry Points Belong in main.py
Your app should have a single clear entry point — either a main.py file or a CLI app using argparse or typer.

Example:

# main.py
from app.api.server import start_server

if __name__ == "__main__":
    start_server()
This keeps your app bootstrapping logic separate from your core logic.

7. Use __init__.py Wisely
Don’t clutter every __init__.py with logic or wildcard imports. Instead:

Keep it clean
Use it for exposing clean module APIs
Only import what’s meant to be publicly accessible
Bad:

# my_project/__init__.py
from .module1 import *
from .module2 import *
Good:

# my_project/__init__.py
from .module1 import ClassA, func_b
8. Add Tooling from Day 1
Senior engineers bake tooling into the project early:

Formatters: black, isort or ruff
Linters: flake8, pylint
Type Checkers: mypy, pyright
Pre-commit hooks: Automate checks before pushing
Add a pyproject.toml to centralize config where possible.

9. Don’t Be Afraid to Refactor
Your first structure won’t be perfect. That’s okay.

But senior engineers refactor relentlessly. They create README.md files in each submodule, document decisions, and prune unused code ruthlessly.

Use tools like:

poetry for dependency management
coverage to track test coverage
mkdocs or Sphinx for documentation